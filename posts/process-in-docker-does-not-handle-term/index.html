<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Docker 里的进程为什么没有处理 TERM 信号 | Jan's Blog</title><meta name=keywords content><meta name=description content="现象 在一个部署在 Kubernetes 的项目里，每次重新部署的都会发现有两个 pods 处于 terminating 状态的时间特别长，于是着手分析这个问题。 Kubernetes 是如何关闭一个容器的？文档 Pods - Kubernetes 介"><meta name=author content="Zhen Zhijian"><link rel=canonical href=https://jan365.org/posts/process-in-docker-does-not-handle-term/><link crossorigin=anonymous href=/assets/css/stylesheet.c497b7a7cbdca85553f94851c1c75c9bdb9f591fb1d632a468606eb623c5db7a.css integrity="sha256-xJe3p8vcqFVT+UhRwcdcm9ufWR+x1jKkaGButiPF23o=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://jan365.org/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jan365.org/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jan365.org/favicon-32x32.png><link rel=apple-touch-icon href=https://jan365.org/apple-touch-icon.png><link rel=mask-icon href=https://jan365.org/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-47790058-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="Docker 里的进程为什么没有处理 TERM 信号"><meta property="og:description" content="现象 在一个部署在 Kubernetes 的项目里，每次重新部署的都会发现有两个 pods 处于 terminating 状态的时间特别长，于是着手分析这个问题。 Kubernetes 是如何关闭一个容器的？文档 Pods - Kubernetes 介"><meta property="og:type" content="article"><meta property="og:url" content="https://jan365.org/posts/process-in-docker-does-not-handle-term/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-12-02T20:11:39+08:00"><meta property="article:modified_time" content="2019-12-02T20:11:39+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Docker 里的进程为什么没有处理 TERM 信号"><meta name=twitter:description content="现象 在一个部署在 Kubernetes 的项目里，每次重新部署的都会发现有两个 pods 处于 terminating 状态的时间特别长，于是着手分析这个问题。 Kubernetes 是如何关闭一个容器的？文档 Pods - Kubernetes 介"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://jan365.org/posts/"},{"@type":"ListItem","position":2,"name":"Docker 里的进程为什么没有处理 TERM 信号","item":"https://jan365.org/posts/process-in-docker-does-not-handle-term/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Docker 里的进程为什么没有处理 TERM 信号","name":"Docker 里的进程为什么没有处理 TERM 信号","description":"现象 在一个部署在 Kubernetes 的项目里，每次重新部署的都会发现有两个 pods 处于 terminating 状态的时间特别长，于是着手分析这个问题。 Kubernetes 是如何关闭一个容器的？文档 Pods - Kubernetes 介","keywords":[],"articleBody":"现象 在一个部署在 Kubernetes 的项目里，每次重新部署的都会发现有两个 pods 处于 terminating 状态的时间特别长，于是着手分析这个问题。\nKubernetes 是如何关闭一个容器的？文档 Pods - Kubernetes 介绍，Kubernetes 会向容器里的进程发 TERM 信号，如果进程在一定时间（默认30秒）内没有关闭，Kubernetes 会发 KILL 信号。\n猜想是因为进程没有处理 TERM 信号，在30秒超时后才被 KILL 信号关闭。验证猜想：\n$ time kubectl delete pod POD_NAME 可以看到用时大概是30秒，一定程度上验证了这个猜想。再进一步，直接向进程发 TERM 信号：\n$ kubectl exec -it POD_NAME -- kill -TERM 1 $ kubectl get pods Pod 还在，没有任何反应，可以验证进程没有处理 TERM 信号。\n然而，shell 里直接运行程序，再发 TERM 信号，进程会马上关闭。那么现在问题是为什么进程在 Docker 里就不处理 TERM 信号了？\n到这里，直觉告诉我们，在程序里显式处理 TERM 信号大概能解决问题。然而，我还是想知道为什么到了 Docker 环境情况会变得不一样。我们先来看看信号是如何工作的。\n信号如何工作 信号的处理有以下3种情况：\n如果进程注册了信号的处理函数，那么内核会调用相应的函数来处理； 如果进程设置了忽略该信号，则内核直接忽略； 如果进程设置了屏蔽该信号，则内核会放到队列里； 对于部分信号，如果既没有注册处理函数，也没有忽略和屏蔽，则内核会有相应的默认处理，通过 man 7 signal 可以看到，TERM 的默认处理是关闭进程。 我们可以在 /proc/ 文件系统里观察进程的信号设置：\n$ kubectl exec POD_NAME -- grep Sig /proc/1/status SigQ:\t0/15733 SigPnd:\t0000000000000000 SigBlk:\t0000000000000000 SigIgn:\t0000000001001000 SigCgt:\t0000000180000002 SigBlk、SigIgn、SigCgt 分别是屏蔽、忽略和捕捉（即注册了处理函数）的mask，十六进制，转成二进制后，每一位对应一个信号编号。kill -l 可以列出信号编号对应的信号。\n**通过上面的信息可以发现编号15的 TERM 信号在3组 mask 里都没有，应该属于情况4，由内核默认处理，也就是关闭进程。**但是实际上并不符合预期。我们做一些实验分析。\n分析 为了简化问题，做了一些尝试后发现只需要在 docker 环境里跑 sleep 进程就能重现。\n$ docker run -it --rm -d alpine /bin/sleep 3600 # 创建一个容器，跑 sleep 进程 44c2fa4ba13066e3b10f78484144fdc06bb87d132a87006a697521fa629e6f74 $ docker exec -it 44c2fa4ba13066 /bin/sh # 进入容器，跑 shell / # grep Sig /proc/1/status # sleep 没有任何信号处理的设置 SigQ:\t0/7866 SigPnd:\t0000000000000000 SigBlk:\t0000000000000000 SigIgn:\t0000000000000000 SigCgt:\t0000000000000000 / # kill -TERM 1 # 向 sleep 进程发信号 / # ps -ef # 没有默认处理，没有关闭 PID USER TIME COMMAND 1 root 0:00 /bin/sleep 3600 7 root 0:00 /bin/sh 13 root 0:00 ps -ef 是 Docker 在信号处理上做了一些特殊处理吗？从原理上分析是没有的，我们通过实验来验证，还是在上面的环境里，我们在 shell 后台跑一个 sleep 进程，再发信号试试。\n/ # sleep 1800 \u0026 / # ps -ef PID USER TIME COMMAND 1 root 0:00 /bin/sleep 3600 7 root 0:00 /bin/sh 16 root 0:00 sleep 1800 17 root 0:00 ps -ef / # kill -TERM 16 / # [1]+ Terminated sleep 1800 这次 sleep 进程符合预期正常关闭了。那么原因很明显的，特殊的是 PID 1。\n特殊的 PID 1 man 2 kill 告诉我们：\nThe only signals that can be sent to process ID 1, the init process, are those for which init has explicitly installed signal handlers. This is done to assure the system is not brought down accidentally. PID 1 进程通常是 systemd、init，扮演着重要的角色，对信号的处理是极其谨慎的，防止意外退出导致 Kernel panic。然而在 docker 里，PID 1成了我们要运行的程序，但却享受着内核的特殊“保护”。\n结论 在 Docker 里，一定要显式处理 TERM 信号。\n","wordCount":"1193","inLanguage":"en","datePublished":"2019-12-02T20:11:39+08:00","dateModified":"2019-12-02T20:11:39+08:00","author":{"@type":"Person","name":"Zhen Zhijian"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jan365.org/posts/process-in-docker-does-not-handle-term/"},"publisher":{"@type":"Organization","name":"Jan's Blog","logo":{"@type":"ImageObject","url":"https://jan365.org/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jan365.org/ accesskey=h title="Jan's Blog (Alt + H)">Jan's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jan365.org/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://jan365.org/categories/ title=Categories><span>Categories</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://jan365.org/>Home</a>&nbsp;»&nbsp;<a href=https://jan365.org/posts/>Posts</a></div><h1 class=post-title>Docker 里的进程为什么没有处理 TERM 信号</h1><div class=post-meta><span title='2019-12-02 20:11:39 +0800 +0800'>December 2, 2019</span>&nbsp;·&nbsp;Zhen Zhijian</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e7%8e%b0%e8%b1%a1 aria-label=现象>现象</a></li><li><a href=#%e4%bf%a1%e5%8f%b7%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c aria-label=信号如何工作>信号如何工作</a></li><li><a href=#%e5%88%86%e6%9e%90 aria-label=分析>分析</a></li><li><a href=#%e7%89%b9%e6%ae%8a%e7%9a%84-pid-1 aria-label="特殊的 PID 1">特殊的 PID 1</a></li><li><a href=#%e7%bb%93%e8%ae%ba aria-label=结论>结论</a></li></ul></div></details></div><div class=post-content><h2 id=现象>现象<a hidden class=anchor aria-hidden=true href=#现象>#</a></h2><p>在一个部署在 Kubernetes 的项目里，每次重新部署的都会发现有两个 pods 处于 terminating 状态的时间特别长，于是着手分析这个问题。</p><p>Kubernetes 是如何关闭一个容器的？文档 <a href=https://kubernetes.io/docs/concepts/workloads/pods/pod/#termination-of-pods>Pods - Kubernetes</a> 介绍，Kubernetes 会向容器里的进程发 TERM 信号，如果进程在一定时间（默认30秒）内没有关闭，Kubernetes 会发 KILL 信号。</p><p>猜想是因为进程没有处理 TERM 信号，在30秒超时后才被 KILL 信号关闭。验证猜想：</p><pre tabindex=0><code>$ time kubectl delete pod POD_NAME
</code></pre><p>可以看到用时大概是30秒，一定程度上验证了这个猜想。再进一步，直接向进程发 TERM 信号：</p><pre tabindex=0><code>$ kubectl exec -it POD_NAME -- kill -TERM 1
$ kubectl get pods
</code></pre><p>Pod 还在，没有任何反应，可以验证进程没有处理 TERM 信号。</p><p><strong>然而，shell 里直接运行程序，再发 TERM 信号，进程会马上关闭。<strong>那么现在问题是</strong>为什么进程在 Docker 里就不处理 TERM 信号了？</strong></p><p>到这里，直觉告诉我们，在程序里显式处理 TERM 信号大概能解决问题。然而，我还是想知道为什么到了 Docker 环境情况会变得不一样。我们先来看看信号是如何工作的。</p><h2 id=信号如何工作>信号如何工作<a hidden class=anchor aria-hidden=true href=#信号如何工作>#</a></h2><p>信号的处理有以下3种情况：</p><ol><li>如果进程注册了信号的处理函数，那么内核会调用相应的函数来处理；</li><li>如果进程设置了忽略该信号，则内核直接忽略；</li><li>如果进程设置了屏蔽该信号，则内核会放到队列里；</li><li>对于部分信号，如果既没有注册处理函数，也没有忽略和屏蔽，则内核会有相应的默认处理，通过 <a href=http://man7.org/linux/man-pages/man7/signal.7.html>man 7 signal</a> 可以看到，<strong>TERM 的默认处理是关闭进程</strong>。</li></ol><p>我们可以在 <code>/proc/</code> 文件系统里观察进程的信号设置：</p><pre tabindex=0><code>$ kubectl exec POD_NAME -- grep Sig /proc/1/status

SigQ:	0/15733
SigPnd:	0000000000000000
SigBlk:	0000000000000000
SigIgn:	0000000001001000
SigCgt:	0000000180000002
</code></pre><p>SigBlk、SigIgn、SigCgt 分别是屏蔽、忽略和捕捉（即注册了处理函数）的mask，十六进制，转成二进制后，每一位对应一个信号编号。<code>kill -l</code> 可以列出信号编号对应的信号。</p><p>**通过上面的信息可以发现编号15的 TERM 信号在3组 mask 里都没有，应该属于情况4，由内核默认处理，也就是关闭进程。**但是实际上并不符合预期。我们做一些实验分析。</p><h2 id=分析>分析<a hidden class=anchor aria-hidden=true href=#分析>#</a></h2><p>为了简化问题，做了一些尝试后发现只需要在 docker 环境里跑 sleep 进程就能重现。</p><pre tabindex=0><code>$ docker run -it --rm -d alpine /bin/sleep 3600 # 创建一个容器，跑 sleep 进程

44c2fa4ba13066e3b10f78484144fdc06bb87d132a87006a697521fa629e6f74

$ docker exec -it 44c2fa4ba13066 /bin/sh  # 进入容器，跑 shell
/ # grep Sig /proc/1/status # sleep 没有任何信号处理的设置

SigQ:	0/7866
SigPnd:	0000000000000000
SigBlk:	0000000000000000
SigIgn:	0000000000000000
SigCgt:	0000000000000000

/ # kill -TERM 1 # 向 sleep 进程发信号
/ # ps -ef # 没有默认处理，没有关闭

PID   USER     TIME  COMMAND
    1 root      0:00 /bin/sleep 3600
    7 root      0:00 /bin/sh
   13 root      0:00 ps -ef
</code></pre><p>是 Docker 在信号处理上做了一些特殊处理吗？从原理上分析是没有的，我们通过实验来验证，还是在上面的环境里，我们在 shell 后台跑一个 sleep 进程，再发信号试试。</p><pre tabindex=0><code>/ # sleep 1800 &amp;
/ # ps -ef

PID   USER     TIME  COMMAND
    1 root      0:00 /bin/sleep 3600
    7 root      0:00 /bin/sh
   16 root      0:00 sleep 1800
   17 root      0:00 ps -ef

/ # kill -TERM 16
/ #
[1]+  Terminated                 sleep 1800
</code></pre><p>这次 sleep 进程符合预期正常关闭了。那么原因很明显的，<strong>特殊的是 PID 1</strong>。</p><h2 id=特殊的-pid-1>特殊的 PID 1<a hidden class=anchor aria-hidden=true href=#特殊的-pid-1>#</a></h2><p><a href=http://man7.org/linux/man-pages/man2/kill.2.html#NOTES>man 2 kill</a> 告诉我们：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>The only signals that can be sent to process ID 1, the init process,
</span></span><span style=display:flex><span>are those for which init has explicitly installed signal handlers.
</span></span><span style=display:flex><span>This is done to assure the system is not brought down accidentally.
</span></span></code></pre></div><p>PID 1 进程通常是 systemd、init，扮演着重要的角色，对信号的处理是极其谨慎的，防止意外退出导致 <a href=https://en.wikipedia.org/wiki/Kernel_panic>Kernel panic</a>。然而在 docker 里，PID 1成了我们要运行的程序，但却享受着内核的特殊“保护”。</p><h2 id=结论>结论<a hidden class=anchor aria-hidden=true href=#结论>#</a></h2><p>在 Docker 里，一定要显式处理 TERM 信号。</p></div><footer class=post-footer><ul class=post-tags></ul></footer><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//blog-ywllbb4f2v.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2022 <a href=https://jan365.org/>Jan's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>